# DRust

## 摘要

DSM因为内存一致性需要大量的同步操作而性能不佳

DRust是一种基于Rust编程语言实现的DSM

它利用了Rust编程语言内嵌的所有权模型

所有权模型自动限制了读写顺序

如果runtime可以利用这一特性，则内存一致性协议的实现将会被简化

文末会将DRust和GAM、Grappa对比，并且证明DRust的扩展性更好

## 简介

DSM不仅通过使用多个处理器提供了并行计算的能力，而且提供了统一且连续的内存视图，简化了分布式应用程序的开发

DSM早期因为网路速度低而性能不佳，随着网络技术的进步，DSM仍然未能达到令人满意的水平。其在可扩展性和与单机系统的比较下表现不佳，主要原因是其为了确保服务器之间的内存一致性，而进行了密集的同步操作

现在的DSM一般都遵循一个原则，对于每个要访问的数据块，该块要么位于一个节点上(允许读和写)，要么复制到多个节点上(只允许读)。如果一个服务器要访问一个数据块，在此之前，DSM检查该块状态，使其在其他服务器上的副本失效，然后把数据块传输给请求的服务器。这个过程需要很多网络通信，即使用了RDMA，也很慢。所以减少同步次数，很关键。

Spark的RDD通过不可变性、粗粒度分区、惰性计算、血缘关系等机制，减少了同步次数，但是其通用性较低

现有的DSM采用了通用的方法来实现内存一致性，这使得其不考虑程序的语义信息，直接使用大量的同步操作。但是现在很多并发程序都是用SWMR原则来编写的，如果能够利用这种语义信息，那么就可以消除在访问数据之前检查远程数据块状态的需要，从而提高性能。那么问题是，如何把这样的语义信息提供给DSM来识别和利用呢？所以需要设计一种机制来使运行时能够将编程语言中的语义信息传递给DSM
