# DRust

## 摘要

DSM因为内存一致性需要大量的同步操作而性能不佳

DRust是一种基于Rust编程语言实现的DSM

它利用了Rust编程语言内嵌的所有权模型

所有权模型自动限制了读写顺序

如果runtime可以利用这一特性，则内存一致性协议的实现将会被简化

文末会将DRust和GAM、Grappa对比，并且证明DRust的扩展性更好

## 简介

DSM不仅通过使用多个处理器提供了并行计算的能力，而且提供了统一且连续的内存视图，简化了分布式应用程序的开发

DSM早期因为网路速度低而性能不佳，随着网络技术的进步，DSM仍然未能达到令人满意的水平。其在可扩展性和与单机系统的比较下表现不佳，主要原因是其为了确保服务器之间的内存一致性，而进行了密集的同步操作

现在的DSM一般都遵循一个原则，对于每个要访问的数据块，该块要么位于一个节点上(允许读和写)，要么复制到多个节点上(只允许读)。如果一个服务器要访问一个数据块，在此之前，DSM检查该块状态，使其在其他服务器上的副本失效，然后把数据块传输给请求的服务器。这个过程需要很多网络通信，即使用了RDMA，也很慢。所以减少同步次数，很关键。

Spark的RDD通过不可变性、粗粒度分区、惰性计算、血缘关系等机制，减少了同步次数，但是其通用性较低

现有的DSM采用了通用的方法来实现内存一致性，这使得其不考虑程序的语义信息，直接使用大量的同步操作。但是现在很多并发程序都是用SWMR原则来编写的，如果能够利用这种语义信息，那么就可以消除在访问数据之前检查远程数据块状态的需要，从而提高性能。那么问题是，如何把这样的语义信息提供给DSM来识别和利用呢？所以需要设计一种机制来使运行时能够将编程语言中的语义信息传递给DSM

AFIM和Midas通过程序员使用提供的API来指定哪个区域是SW的，这比较容易出错而且很麻烦。SWMR是所有权模型的一部分特性，而Rust编程语言就实现了所有权模型，故用Rust编写的DSM就会自动实现SWMR

所有权类型的基本概念是，每个值在其执行过程中都只有一个变量作为其所有者，一个值可以有多个不可变的引用，一个值只可以有一个可变的引用，且不允许其他引用存在。这很自然地实现了SWMR

因为Rust的编译器会在编译时检查所有权和引用规则，所以DSM就避免了这一步骤。即，在写操作时，编译器确保了此时没有其他写操作并且所有读操作都已经完成，故而DSM可以直接把数据块迁移到执行写操作的服务器上，而无需使该数据块在其他服务器上的副本失效；在读操作的时候，编译器确保了此时不会有并发的写操作，故避免了数据不一致的问题。

Drust通过利用Rust的所有权模型，实现了对象级别的并发访问，并自动将单机Rust程序转换为分布式版本。但是DRust的实现有两个难点

第一个。Rust的所有权类型是为单机环境设计的，其对象的内存地址在创建后不变，但是在分布式环境里面，对象是会在不同的服务器之间迁移或复制的，这就可能导致悬空指针，会出现问题。

DRust构建了一个跨服务器的全局堆(每个服务器管理全局地址空间中的一个分区)，每个对象在全局空间中都有唯一的全局地址，任何服务器都可以访问。这就需要重新实现Rust的内存管理构造，以便在全局堆中分配和管理对象。为了确保服务器可以缓存对象，DRust设计了一个基于所有权模型的缓存一致性协议。

一致性协议就是读操作发生的时候，服务器可以缓存，但是不会更改对象的地址和值，写操作发生时，会把对象挪到执行写操作的服务器所管理的分区堆中，这使得使用旧地址的副本自动失效，后续读者读的时候会自动更新到新的地址

第二个。Rust的标准库和程序是为单机环境设计的，运行在服务器A上的程序无法在服务器B上创建线程，更不用说同步操作了。所以DRust重构了Rust中线程std::thread::spawn、通信通道std::sync::mpsc、共享状态锁std::sync::{Rwlock、Mutex}等库，并且接口相同。这些都是在前面所有权内存模型的基础上实现的。

除了重构标准库外，每个节点上都有一个运行时来监控资源使用情况，并且和全局控制器配合，实现内存管理和线程调度

DRust(2024)比GAM(2018)好，比Grappa(2015)更好，比单机环境差一点

> GAM和Grappa比单机环境差多少？

## 所有权

在内存管理的安全性和数据共享方面，编程语言对于内存抽象层次和管理效率有不同的考量，比如Java就是提供了高层次的内存抽象，通过垃圾回收自动管理内存，虽然简化了编程，但是引入了额外的运行时开销；像C就是提供了低层次的内存控制，程序员需要手动管理内存分配和释放，虽然性能高，但是出错风险也增加了。Rust在性能和安全方面做了一个不错的权衡，对内存管理的抽象程度比较适中，其所采用的方法是所有权。

前面说到Rust为了性能而降低了内存抽象层次，但其安全问题也相应提升，为了保证程序的内存和线程安全，所有权通过在编译时进行严格的类型检查来完成。

每个对象都有生命周期，并且每个对象在任何时候都只能有一个所有者，编译器会静态跟踪每个对象的生命周期，一旦其所有者离开作用域，该对象就会被释放。

临时访问数据而不转移所有权时，程序需要创建引用，来借用对象的所有者permission，用完之后需要return。在安全性方面，引用的生命周期必须在对象的生命周期之内，这样就避免出现悬空指针；在共享数据方面，不可变引用可以有多个，但不许有可变引用的存在，若存在可变引用，则不允许有其他引用的存在。这些都是类型系统的限制(编译器来检查)

赋值、函数调用、线程创建、消息传递会出现所有权转移，这要求该对象必须没有其他借用

## 动机

DSM是为了帮助分布式编程的，让其像在单机环境下编程一样。核心就是内存一致性模型，再核心就是缓存一致性协议。模仿了多核CPU的硬件缓存一致性，通过在不同的服务器之间发送控制信息来同步内存状态，但是在物理上分离的服务器之间通信，其延迟太高了(为了说明延迟高，作者做了有GAM实验)。

利用所有权模型实现的缓存一致性，会好很多

> 硬件缓存一致性？如何实现？
